#include <iostream> // 
#include <cstdio> // like stdio.h
#include <string> // like string.h string is like a char array

namespace First {
    namespace nested {
        void foo() {
            std::cout << "first nested namespace in foo\n" << std::endl;
        }
    }
}


namespace Second {
    void foo() {
        std::cout << "second namespace in foo\n" << std::endl;
    
    }
}

// global func
void foo() {
    std::cout << "global foo\n" << std::endl;
}

using namespace::std;

int main(int argc, char **argv)
{
/*    using namespace First::nested;
    First::nested::foo();
    ::foo();
    using namespace Second;
    Second::foo();
*/

}

/*

#include <iostream>
using namespace std;

// Bir sınıf tanımlayalım
class Rectangle {
private:
    int length;
    int width;

public:
    // Yapıcı (constructor) fonksiyon
    Rectangle(int len, int wid) {
        length = len;
        width = wid;
    }

    // Alanı hesaplayan fonksiyon
    int area() {
        return length * width;
    }
};

int main() {
    // Rectangle sınıfından bir nesne oluşturalım
    Rectangle rect(5, 4);

    // Alanını hesaplayalım ve ekrana yazdıralım
    cout << "Rectangle Area: " << rect.area() << endl;
	/*privite publix olursa burda rect. yazdığımda tüm değerlerine ulaşabilirim*/
	/*eğer privite olarak kalırsa sadece area fonksiyonuna oluşabilirim ve 
	area fonksiyonu da privite fonksionuna ulaşabilir çünkü aynı classtalar. */
    return 0;
}

*/


/*
*   
* RAII (Resource Acquisition Is Initialization) = otomatik kaynak init, free, allocation file control vs.
*/


// cin, cout, cerr
// stdin, stdout, stderr.


// adres
/*
*      using namespace std;
*
*   string foo = "I am foo";
*   string bar = "I am bar";
*
*
*   string& fooRef = foo; // This creates a reference to foo.
*   fooRef += ". Hi!"; // Modifies foo through the reference
*   cout << fooRef << "\n"; // Prints "I am foo. Hi!"
*
*   // Doesn't reassign "fooRef". This is the same as "foo = bar", and
*   //   foo == "I am bar"
*   // after this line.
*   cout << &fooRef << "\n "; //Prints the address of foo
*   fooRef = bar;
*   cout << &fooRef << "\n "; //Still prints the address of foo
*   cout << fooRef << "\n ";  // Prints "I am bar"
*   cout << foo << "\n "; // Prints "I am bar"
*/


// function overloading
/*
* Aynı isimde ama farklı türde fonksiyonları beraber kullanabilmek
*/

// function deafult init
/*
* fonksiyon isminde default olarak bir değer verilebilir "void func(int a = 1, int b = 12)"
* bu fonksiyon default olarak çağrıldığında a ve b olarak kullanılabilir.
*/

//    std::cout << "anan" << std::endl;
/*
*   std (standart library) kütüphane içerisindeki bileşenlere ulaşmak için :: kullanılır << ile aktarma yapılır 0 1 gibi
*   cout ise standart çıktı anlama gelmektedir.
*/

// string is a char 
/*
*   and they are can be append like std::cout << mystring1 + mystring2 << std::endl; == mystring1.append(mystring2); same thing
*/

// .h yerine .hpp kulllanımı derleme sırasında dosyanın c değil cpp olduğunu belirtir ve karışıklığın önüne geçer. bazı durumlarda karışabiliyormuş.